import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as sps

# (a) Сформируйте матрицу данных X размером 4×100, изначально заполненную нулями.
X = np.zeros((4, 100))

# (b) Заполните первую строку независимыми одинаковораспределёнными случайными величинами (i.i.d) N(165,25)
# (моделированиеростачеловека), а вторую строку - с i.i.d. случайными величинами N(62,100) (имитация веса человека).
X[0] = sps.norm(165, 25).rvs(size=100)
X[1] = sps.norm(62, 100).rvs(size=100)

# (c) Имеют ли эти данные смысл ? Все ли пары величин разумны ?
# Как бы вы очистили/предварительно обработали эти данные ? Проведите очистку.

# Рассчитываем IMT для каждой пары роста и веса.
IMT = X[1] / np.power(X[0] / 100, 2)

print("Максимальный ИМТ: ", np.max(IMT))
print("Минимальный ИМТ: ", np.min(IMT))

# Т.к значения ИМТ очевидно необычные, то мы "нормализуем" их
X[0] = np.int32(15 * np.random.randn(100) + 180) # Рост

IMT = 4 * np.random.randn(100) + 30

print("Максимальный ИМТ: {0}".format(round(np.max(IMT)), 1))
print("Минимальный  ИМТ: {0}".format(round(np.min(IMT)), 1))

# (d) Визуализируйте / нанесите на график свои предварительно обработанные
# данные.
plt.hist(IMT)
plt.xlabel("IMT")
plt.show()

# (e) Вычислите отношение веса и роста для каждой выборки и постройте гистограмму соотношений
otn = X[0] / X[1]

plt.hist(otn)
plt.xlabel("Рост/Вес")
plt.show()

# (f) Смоделируйте уровень глюкозы каждого человека как зашумленную версию его отношения веса к росту
# (соотношение + шум) и сохраните это значение в третьей строке матрицы данных X. Пусть шум будет i.i.d. N (0, σ^2),
# σ - стандартное отклонение - параметр.

noiseMC = np.random.normal(0, np.std(otn) / 100)
X[2] = noiseMC + otn

# g) Будем моделировать человека как здорового (метка = 0), если его уровень
# глюкозы (как определено выше) ниже порогового значения τ, и как диабетика в
# противном случае (метка = 1). Сохраните эти метки в четвертой строке
# матрицы данных X.
t = 1.2

for i in range(100):
    if X[2][i] < t:
        X[3][i] = 1
    else:
        X[3][i] = 0

print(X)

print(np.std(otn))

# (h) Визуализируйте / нанесите на график сгруппированные данные для
# различных значений σ и τ.

x = 0.0
i = 0
it = np.zeros(10)
# Создаем матрицу 10 x 10
alpha_t = np.zeros((10, 10), dtype=np.int32)

while x < 0.9:
    it[i] = round(x, 1)
    i += 1
    x += 0.1

print(it)

for i, f in enumerate(it):
    alt = np.random.normal(0, f) + otn
    print(f)
    print(i)
    for j, g in enumerate(it):
        alpha_t[i, j] = np.sum(alt < (g * 10))

print(alpha_t)

plt.figure(figsize=(20, 20))
plt.title("Больные от σ и τ")

for i in range(10):
    plt.plot(it, alpha_t[i], label='σ={0}, τ={0}'.format(it[i], it[i]))
    plt.plot(it, alpha_t[:, i])

plt.xlabel("σ и τ")

plt.grid()
plt.legend()
plt.show()